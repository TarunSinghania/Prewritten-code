//0(2^n*n*n)time
//2^n*n space
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define fr(i,a,b) for(int i =a ; i < b; i++)
#define mkp make_pair 
#define pb push_back
#define speed   ios::sync_with_stdio(false), cin.tie(0) , cout.tie(0)
#define sz 500;
#define ff first
#define ss second
#define MAX 10005
#define pr(a,n) fr(i,0,n){cout<<a[i]<<" ";}cout<<endl;
#define MAXBLOCKS 10000
#define all(x) x.begin(),x.end()
#define INF 10000000
#define MOD 1000000007
#define prm(m,r,c) fr(i,0,r){fr(j,0,c){cout<<m[i][j]<<" "; }cout<<endl;}
#define fillm(m,r,c,k) fr(i,0,r)fr(j,0,c)m[i][j]=k;
#define endl '\n'
#define MAXVERTICES 16
#define INF_COST 2e18
#define prv(v) for(auto s: v){cout<<s<<" ";}cout<<endl; 
//CHANGE MAXVERTICES ACCORDINGLY
int n,m;
ll dp[1<<MAXVERTICES][MAXVERTICES];
//dp[mask][i] be the length of the shortest Hamiltonian walk in the subgraph generated by vertices in mask, that ends in the vertex i.
int g[MAXVERTICES][MAXVERTICES];
int d[MAXVERTICES][MAXVERTICES];

void init(){
  for(int i  = 0 ; i < (1<<n) ; i++){
    fr(j,0,n)
      dp[i][j]=INF_COST;
  }
  fr(i,0,n)
  dp[(1<<i)][i]=0;
}

main(){
  cin>>n>>m;
    fr(i,0,m)
    {
      int a,b,x;
      cin>>a>>b>>x;
      a--;b--;
      g[a][b]=1;g[b][a]=1;
      d[a][b]=x;d[b][a]=x;
     }

     init();  
     for(int mask = 1; mask < (1<<n) ; mask++){
        
        for(int i  = 0 ; i <n ; i++)
        {
          if(!(mask&(1<<i)))continue;
        
          int prev_mask = mask^(1<<i);
          for(int j =0 ; j < n ; j ++)
          {
            if(g[j][i])
            dp[mask][i]=min(dp[mask][i],dp[prev_mask][j]+d[j][i]);
           }
         
        }
      }
    ll ans = INF_COST ;int ends_at =-1;
     for(int i = 0 ; i < n ; i++){
        if(dp[(1<<n)-1][i] < ans)
          ans=dp[(1<<n)-1][i],ends_at=i+1;
     }
     cout<<"walk ends at i"<<ends_at<<"with cost"<<ans<<endl;
}